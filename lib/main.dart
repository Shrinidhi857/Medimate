import 'dart:io';

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:hive/hive.dart';
import 'package:hive_flutter/adapters.dart';
import 'package:medimate/Theme/darkmode.dart';
import 'package:medimate/Theme/lightmode.dart';
import 'package:medimate/pages/Addmedication.dart'; // Update path if different
import 'package:medimate/pages/Calendar.dart';
import 'package:medimate/pages/guide_page.dart';
import 'package:medimate/pages/home.dart';
import 'package:medimate/pages/splash.dart';
import 'firebase_options.dart'; // Generated by `flutterfire configure`
import 'dart:convert';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:awesome_notifications/awesome_notifications.dart';
import 'package:firebase_auth/firebase_auth.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await AwesomeNotifications().initialize(
    'resource://drawable/icon',
    [
      NotificationChannel(
        channelKey: "medication_reminder",
        channelName: "Medication Reminders",
        channelDescription: "Reminders to take your medications on time",
        importance: NotificationImportance.Max,
        defaultPrivacy: NotificationPrivacy.Private,
        enableVibration: true,
        channelShowBadge: true,
        enableLights: true,
        playSound: true,
        locked: true,
      ),
    ],
    debug: true,
  );


  await Hive.initFlutter();
  var box =await Hive.openBox('mybox');

  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.android,
  );
  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );



  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  @override
  void initState() {
    AwesomeNotifications().isNotificationAllowed().then(
          (isAllowed) {
        if (!isAllowed) {
          AwesomeNotifications().requestPermissionToSendNotifications();
        }
      },
    );

    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'MediMate',
      theme:lightMode,
      darkTheme: darkMode,
      home: SplashPage(),
      routes: {
        '/home': (context) =>  HomePage(),
        '/CalendarPage': (context) => CalendarPage(),
        '/bluetooth': (context) =>   WiFiSocketScreen(),
        '/addMedication': (context) => AddMedicationPage(),
        '/guidepage': (context) => GuidePage(),
      }, // Stateful widget below
    );
  }
}

class HomeWrapper extends StatefulWidget {
  const HomeWrapper({super.key});

  @override
  State<HomeWrapper> createState() => _HomeWrapperState();
}

class _HomeWrapperState extends State<HomeWrapper> {
  @override
  Widget build(BuildContext context) {
    return const AddMedicationPage(); // Replace with your main home page
  }
}
class WiFiSocketScreen extends StatefulWidget {
  const WiFiSocketScreen({super.key});
  @override
  State<WiFiSocketScreen> createState() => _WiFiSocketScreenState();
}

class _WiFiSocketScreenState extends State<WiFiSocketScreen> {
  String message = "Ready to connect";
  Socket? socket;
  bool isConnecting = false;
  String? get userId => FirebaseAuth.instance.currentUser?.uid;
  String raspberryPiIP = "192.168.255.38";
  late int port=3000;


  @override
  void initState() {
    super.initState();
    // Don't auto-connect, let user initiate connection
  }

  Future<void> _sendUserIdToRaspberryPi() async {
    if (isConnecting) return;

    setState(() {
      message = "Connecting...";
      isConnecting = true;
    });

    try {
      final uid = userId ?? "unknown_user";
      print("📤 Attempting to connect to $raspberryPiIP:$port");

      try {
        final result = await InternetAddress.lookup(raspberryPiIP);
        if (result.isEmpty || result[0].rawAddress.isEmpty) {
          throw Exception("Cannot resolve Raspberry Pi IP address");
        }
        print("✅ Network check passed. IP is reachable.");
      } catch (e) {
        throw Exception("Network error: Cannot reach Raspberry Pi ($e)");
      }

      print("Attempting socket connection...");
      socket = await Socket.connect(
        raspberryPiIP,
        port,
        timeout: const Duration(seconds: 100),
      );
      print("✅ Socket connected successfully");
      setState(() => message = "Connected! Sending UID...");

      print("Sending UID: $uid");
      socket!.write(uid);
      await socket!.flush();
      print("✅ UID sent successfully!");
      setState(() => message = "✅ UID sent successfully!");

      socket!.listen(
            (data) {
          final response = utf8.decode(data);
          print("📥 Received from server: $response");
          setState(() => message = "✅ Server response: $response");
        },
        onError: (error) {
          print("❌ Socket error during listen: $error");
          setState(() => message = "❌ Socket error: $error");
        },
        onDone: () {
          print("📡 Connection closed by server (listen)");
          setState(() => message = "Connection closed by server");
        },
      );

      Future.delayed(const Duration(seconds: 5), () {
        _closeConnection();
      });

    } catch (e) {
      print("❌ Connection error: $e");
      setState(() => message = "❌ Error: $e");
    } finally {
      setState(() => isConnecting = false);
    }
  }

  void _closeConnection() {
    try {
      if (socket != null) {
        socket!.close();
        socket = null;
        setState(() => message = "Connection closed");
      }
    } catch (e) {
      print("Error closing socket: $e");
    }
  }

  @override
  void dispose() {
    _closeConnection();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Connect to Dispenser"),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                message,
                style: const TextStyle(fontSize: 18),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: isConnecting ? null : _sendUserIdToRaspberryPi,
              child: Text(isConnecting ? "Connecting..." : "Connect to Dispenser"),
            ),
            const SizedBox(height: 10),
            Text(
              "Raspberry Pi IP: $raspberryPiIP:$port",
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      ),
    );
  }
}